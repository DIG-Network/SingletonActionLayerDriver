// emit_child_action.rue
// An action puzzle for the action layer that emits a child singleton
//
// Action Layer Interface (CHIP-0050):
//   Action receives: (state . action_solution) where state = (ephemeral . persistent)
//   Action returns: ((new_ephemeral . new_persistent) . conditions)
//
// This action:
//   - Creates a 0-amount launcher coin (ephemeral, spent in same bundle)
//   - Asserts the launcher's announcement (ensures launcher is spent correctly)
//   - Increments the counter in persistent state
//
// Curried: child_inner_puzzle_hash - determines what inner puzzle the child singletons get
// Solution structure: (my_singleton_coin_id . ()) - just needs the parent coin ID
// Persistent state structure: (counter . marker)

import constants::{SINGLETON_LAUNCHER_HASH, curry_singleton_hash};

// Type definitions for structured destructuring
type Persistent = (Int, Int);
type State = (Any, Persistent);
// Solution now just contains the coin ID - child puzzle hash comes from currying
type Solution = (Bytes32, Any);

export fn main(
    // Curried: the inner puzzle hash for child singletons
    child_inner_puzzle_hash: Bytes32,
    // From action layer: (ephemeral . persistent)
    state: State,
    // Solution: (my_singleton_coin_id . _)
    action_solution: Solution,
) -> Any {
    // Destructure state: (ephemeral . (counter . marker))
    let (ephemeral, persistent) = state;
    let (counter, marker) = persistent;

    // Get coin ID from solution
    let (my_singleton_coin_id, _rest) = action_solution;

    // Compute the child launcher ID (parent=my_coin, puzzle=launcher, amount=0)
    let child_launcher_id = coinid(my_singleton_coin_id, SINGLETON_LAUNCHER_HASH, 0);

    // Compute the child singleton's full puzzle hash using the curried inner puzzle hash
    let child_singleton_puzzle_hash = curry_singleton_hash(child_launcher_id, child_inner_puzzle_hash);

    // The launcher announcement message: tree_hash([child_singleton_puzzle_hash, 1, nil])
    let launcher_message = tree_hash([child_singleton_puzzle_hash, 1, nil]);

    // Build conditions
    let conditions: List<Condition> = [
        // Create the child launcher coin (0-amount, ephemeral)
        CreateCoin {
            puzzle_hash: SINGLETON_LAUNCHER_HASH,
            amount: 0,
        },
        // Assert the launcher announcement - ensures launcher is spent correctly
        AssertCoinAnnouncement {
            id: sha256(child_launcher_id + launcher_message),
        },
    ];

    // Build new state: increment counter, keep marker
    let new_counter = counter + 1;
    let new_persistent: Persistent = (new_counter, marker);

    // Return ((new_ephemeral . new_persistent) . conditions)
    ((ephemeral, new_persistent), conditions)
}
