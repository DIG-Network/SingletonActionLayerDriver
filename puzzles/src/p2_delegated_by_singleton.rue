// P2_DELEGATED_BY_SINGLETON PUZZLE
// Reference: https://github.com/Yakuhito/slot-machine/blob/master/puzzles/singleton/p2_delegated_by_singleton.clsp
//
// This puzzle delegates a spend to a singleton.
// The singleton authorizes the spend by sending a SEND_MESSAGE condition.
//
// CURRY: SINGLETON_MOD_HASH, SINGLETON_STRUCT_HASH, NONCE

const RECEIVE_MESSAGE: Int = 67;
// Message mode 23 = puzzle hash to coin ID
const MESSAGE_MODE_PH_TO_COIN: Int = 23;

type PuzzleFn = fn(input: Any) -> List<Any>;

export fn main(
    // Curried args
    singleton_mod_hash: Bytes32,
    singleton_struct_hash: Bytes32,
    nonce: Int,
    // Solution
    singleton_inner_puzzle_hash: Bytes32,
    delegated_puzzle: Any,
    delegated_solution: Any,
) -> List<Any> {
    // Compute full singleton puzzle hash
    let singleton_puzzle_hash = curry_tree_hash(
        singleton_mod_hash,
        [singleton_struct_hash, singleton_inner_puzzle_hash]
    );

    // Compute delegated puzzle hash
    let delegated_puzzle_hash = tree_hash(delegated_puzzle);

    // Run the delegated puzzle using unchecked_cast for dynamic apply
    let delegated_conditions = unchecked_cast::<PuzzleFn>(delegated_puzzle)(delegated_solution);

    // Return: message assertion + delegated conditions
    [
        [RECEIVE_MESSAGE, MESSAGE_MODE_PH_TO_COIN, delegated_puzzle_hash, singleton_puzzle_hash],
        ...delegated_conditions,
    ]
}
